#include <iostream>

using std::cout;
using std::cin;
using std::endl;

#pragma region 전처리기
/*
=> 전처리기

- 실행 파일을 생성하는 과정에서 컴파일하기 직전, 소스 파일내에 존재하는
선행 처리 지시문을 처리하는 작업을 의미한다.

- 전처리기가 실행 되면 각 코드 파일에서 지시자를 찾기 시작한다.
ㄴ 지시자는 #으로 시작으로 줄 바꿈으로 끝나는 코드

-> 선행 처리를 위한 명령에는 맨 앞에 #기호가 붙는다는 공통점이 있다.

=> C/C++ 코드를 실행하는 과정

- 순서 : 전처리기 -> 컴파일러 -> 어셈블러 -> 링커

- 전처리기(PreProcessor)
ㄴ 헤더 파일 삽입, 코드의 주석 제거, 문법 검토, 매크로등을 치환하는 역할을 수행한다.

- 컴파일러
ㄴ 어셈블리 파일로 변환을 해준다.

- 어셈블러
ㄴ 어셈블리 코드를 기계어(0 or 1)로 변환하여 오브젝트 파일을 생성한다.

- 링커
ㄴ 각각의 오브젝트 파일들을 묶어서 실행 코드 파일로 변환을 해준다.

----**********
1. 내가 작성한 소스파일은 먼저 소스파일 처리를 하는 선행 처리를 거치고
2. 컴파일 되어
3. 오브젝트 파일이 생성 되고
4. 링커에 의한 실행파일이 된다.

ㄴ [소스 코드] -> [바이너리] -> [실행 파일]
바이너리 : 컴파일러에 의해 생성된 목적 파일
*****************

=> 선행처리를 위한 명령

- 전처리기문 = 전처리기 연산자

- 파일 처리를 위한 전처리기문


-> 최적화 #include "절대 경로" 찾는게 아닌 바로 지정하는법 
1. #include
ㄴ #include <파일 이름> -> 미리 정의된 include 폴더에서 파일을 찾는다.
ㄴ #include "파일 이름" -> 현재의 소스 코드가 저장되어 있는 폴더에서 먼저 찾고
						  파일이 없다면 미리 정의된 include 폴더에서 파일을 찾는다.

- 형태 정의를 위한 전처리기문

* 면접 사골 -> 매크로 vs 상수 => 효율이 상수가 압도적으로 좋다. (컴파일시간, 메모리 사용량)
1. #define
ㄴ #define 키워드는 매크로 상수 또는 매크로 함수를 정의하는 역할을 한다.

2. #undef

- 매크로 해제

3. 조건부 컴파일을 위한 전처리기문
-> C언어로 객체지향을 만들수 있게 만들어 줌
- #if, #ifdef, #ifndef, #else, #elif, #endif

ㄴ #ifdef		: 식별자가 정의되어 있으면 참
ㄴ #ifndef		: 식별자가 정의되어 있지 않으면 참
ㄴ #endif		: 전처리기 부분을 종료 (#if 시리즈)

필수
* 코드 설계 단계에서 적용을 잘 하면 실행 속도에 매우 큰 이득을 얻을 수 있다.
ㄴ 선택적 컴파일 기법

4. pragma 

- 컴파일러의 기능을 확장시킬 수 있게 나온 문법이며 어떤 동작을 정해주기 위해 사용한다.

- 컴파일러의 버전에 따라 동작 여부가 결정된다.
ㄴ 덤으로 OS에 따라서도 동작 여부가 결정된다.

#pragma region 이름
- 코드를 개요, 축소가 가능하게 묶는다.
#pragma endregion

#pragma one : 엔진에서는 없을 수 있으므로 반드시 확인할 것
ㄴ 헤더 파일 중복 방지
ㄴ 링크할 때 헤더 파일이 한번만 포함하게 한다.

#pragma message("Exaple_cpp 수정하지 말것")
ㄴ 컴파일시 출력창에 메세지 출력
ㄴ 주로 협업시 개발자에게 경고를 알려줄 때 사용한다.


*/
#pragma endregion

#pragma region 매크로 상수
/*
=> 매크로 상수를 정의할 때 주의점

1. #define문은 코드를 생성하는 명령이 아니며 매크로의 이름도 일종의 명칭이기 때문에
명칭 규칙에 맞게 작성해야 한다.

-> 매크로의 표기법은 대문자 표기법을 쓴다.
ㄴ 띄어쓰기는 _언더바로 표기한다 -> 스네이크

2. 매크로 이름에는 공백이 들어갈 수 없지만 매크로 실제 값은 공백을 가질 수 있다.
ㄴ EX) #define MSG "똑바로 공부하자"

3. 문자열 상수내에 있는 매크로나 다른 명칭의 일부로 포함된 경우는 치환되지 않는다.

4. 매크로는 중첩 가능
EX)
#define A 3
#define B (A * 3)

5. 값을 가지지 않는 빈 매크로도 정의 가능
EX) #define AAA
ㄴ 위 매크로를 해석하면 값을 가지고 있지 않으며 매크로 상수 자체만 존재한다.

6. 매크로 상수는 단순히 컴파일전에 코드를 튜닝하기 위한 전처리기에 의해서 처리되는
상수이기 때문에 컴파일러 입장에서는 리터널 상수와 동일 시 된다.
ㄴ 리터널 상수화 동일시 -> 컴파일러는 매크로 상수의 존재를 알 수 없다.

*/
#pragma endregion

// 매크로 표기법
// ㄴ 상수의 이름은 모두 대문자 -> (띄어쓰기)스네이크 표기법

// 매크로 정의 방법
// ㄴ #define 매크로명 실제 값

#define EXAMPLE_1 1
#define EXAMPLE_2 1

#undef EXAMPLE_2
#define EXAMPLE_2 2


#define TRUE 1
#define FALSE 0

// 매크로 함수
// ㄴ 간단한 함수를 대체하기 위해 사용 -> 스택 메모리를 절약하기 위해
#define ADD(a) ((a) * (a))

// 스택 => 메모리 용량(1MB) => 허용치를 넘어가면 스택 오버 플로우 발생
// 



void GetMultipleValue(int numA);

void main()
{
	
}

void GetMultipleValue(int numA)
{
	cout << numA * numA << endl;
}
