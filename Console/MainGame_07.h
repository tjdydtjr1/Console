#pragma once
#include <iostream>
#include <vector>

using std::cout;
using std::cin;
using std::endl;
using std::string;
using std::vector;

// 노트패드 C++ 플러그인 설치 => STL 관련 오류체크해줌
#pragma region 템플릿 + 클래스 변수 / 함수
/*
=> 템플릿

- 클래스 또는 함수를 선언할 때 데이터의 타입을 명시하지 않고 클래스 또는 함수를
  정의할 수 있는 기능을 의미한다.

- 템플릿을 이용하면 특정 타입에 종속되지 않는 로직을 작성하는 것이 가능하다.
- 일반화 프로그래밍에 중추적인 역할을 하는 문법이다.
ㄴ 일반화 -> 데이터 형식에 상관없이 로직을 구현하는 것을 의미한다.
ㄴ STL이 C++에서 지원하는 대표적인 일반화 프로그래밍이다.

=> 템플릿 요약
- 컴파일러가 미리 등록된 함수의 틀을 기억해 두었다가 함수가 호출될 때 실제 함수를
  만드는 장치라고도 할 수 있다. (이는 클래스에도 동일하게 적용된다.)

-> 템플릿
ㄴ 여러가지 함수, 클래스를 찍어내는 틀
ㄴ 템플릿의 종류에는 함수 템플릿과 클래스 템플릿이 있다.

1. 함수 템플릿
- 함수 위에 템플릿을 선언한것을 의미한다.
ㄴ 함수 템플릿은 함수마다 선언을 해줘야 한다.

EX)
template<typename T> T Function()
{
	....;
}

2. 클래스 템플릿
ㄴ 클래스위에 템플릿 선언
ㄴ 클래스 템플릿은 선언의 type 부분에 class를 명시해 줘야 한다.

EX)
template <class T1>
template<template<typename, typename> class Contaniner>

=> 템플릿의 특징
- 템플릿만 정의하고 함수를 호출하지 않으면 아무런 일도 일어나지 않는다.
ㄴ 컴파일 타임에 모든 자료형을 받는다.
ㄴ 템플릿을 선언만 하면 메모리를 소모하지 않는다.

- 호출에 의해 템플릿이 구체화 되어 실제 함수가 될 때만 프로그램의 크기가 늘어난다.
- 컴파일러가 컴파일 도중에 각 템플릿 인스턴스에 대한 코드를 생성시켜 준다.
- 템플릿은 헤더 파일 구현을 원칙으로 한다.

->(중요!) 헤더파일에 함수를 직접 구현하는 경우
1. 캡슐화 (접근자, 설정자)
ㄴ C++은 객체지향 언어 -> 캡슐화는 OOP 특징중 1개 -> 캡슐화를 위한 헤더파일 구현 원칙

2. 템플릿
- .h / .cpp로 구분지어 코드를 구현은 가능하다.
ㄴ 하지만 헤더파일에 구현하는걸 권장한다. 
ㄴ 이는 컴파일 순서에 의한 처리 때문이며 보통 상속 구조를 가지고 있다면 컴파일러가
   에러를 발생 시킨다. (컴파일러 진행 순서 -> 헤더파일 -> cpp -> cpp의 헤더파일)

3. 인라인
- 무거운 함수 구조나 연산이 많은 로직이 구현된 함수는 시간의 문제일뿐 언젠가는 반드시
  스택 오버 플로우가 발생할 여지를 지니고 있다.
- 이를 해결하기 위해 함수를 인라인화 시킴으로 실행속도 향상을 얻을 수 있다.
ㄴ 함수를 호출하면 스택의 할당과 반환이라는 과정이 발생 하는데 인라인화가 된 함수는
   이러한 과정을 전혀 거치지 않는다.

-> 인라인 키워드 특징
- 적용을 하면 좋은 사례는 몇가지가 있다.
1. 간결한 코드에 적용하면 좋다.
- 인라인 이라는 키워드는 어디까지나 컴파일러에게 명시적으로 알려주는 키워드 일뿐
  컴파일러가 함수를 인라인화 시킬것인지 아닌지는 결국 컴파일러가 정한다.
- 반대로 인라인 키워드를 붙이지 않았다고 해도 컴파일러가 인라인화 시키는 경우도 있다.

=> 인라인 함수가 왜 필요한지에 대해 이해를 하려면 매크로에 대한 장점/단점에 대해 알고 있으면 좋다.
=> 매크로 함수는 자료형에 독립적이다.
EX)
#define ADD(x)	((x) * (x)) -> x로 올 수 있는 자료형은 자유롭다.
- 인라인으로 선언된 함수를 위의 형태로 정의하려면 각 자료형 타입에 맞는 함수가
  오버로딩으로 선행되어야 한다.

- 매크로 함수와 달리 함수는 자료형에 독립적이지 못한다.
- 이러한 인라인 함수를 자료형에 독립적으로 선언할 수 있게 만들어 주는게 바로 템플릿

=> 컴파일 타임 + 런 타임
처리 단계 (매우 중요!)
1. 소스 파일 병합				- 컴
2. 선행 처리기				- 파
3. 전처리기					- 일
4. 어셈블리					- 과
5. 컴파일러 활동				- 정
6. 오브젝트 파일 분할			- 끝
컴파일과정이 끝나며 -> 템플릿 자료형 확정

런타임 과정 
시동 코드와 표준 라이브러리 파일 병합 -> 링커에 의한 obj 링크 -> 실행 -> 컴파일러 재등장


=> 컴파일 타임
- 개발자는 프로그램을 생성하기 위해서 컴파일이라는 과정을 통해 기계어 코드로 변환된
  실행 가능 프로그램이라는 결과물을 얻을 수 있다.
  ㄴ 이러한 편집과정을 컴파일 타임이라고 부른다.

- 기본적으로 컴파일 타임 에러는 프로그램이 성공적으로 컴파일링 되는 것을 방해하는 
  오류가 있다는 뜻이다.
  ㄴ 신택스 에러 + 파일 참조 오류
- 위와 같은 오류는 컴파일 단계에서 발생하는 일반적인 오류이기 때문에 문제가 발생하면
  컴파일러가 문제가 발생한 라인을 지시해 준다.

=> 런타임
- 컴파일 과정을 마친 프로그램은 사용자에 의해 실행이 되며 이러한 응용프로그램의
  동작 시간을 런타임이라고 할 수 있다.
- 소스코드가 이미 실행 가능한 프로그램으로 컴파일 되었다고 가정을 하더라도 이것은
  여전히 버그가 발생할 수 있는 여지를 가지고 있다.
- 이때 컴파일러의 도움을 받을 수 없기 때문에 링커는 일반적으로 프로그램된 오류 메세지를
  출력하면서 오류처리를 해버린다.

EX) NULL 참조 오류 / 메모리 부족 등등...


=> 클래스 변수 / 함수란?
- 일반적으로 클래스의 멤버 변수 / 함수는 객체를 생성 후 이를 사용하는 것이 가능한 반면
  클래스 변수 / 함수는 객체를 생성하지 않더라도 변수와 함수를 사용하는 것이 가능하다.



*/
#pragma endregion

// 클래스 전방선언 일단 참고
//class MainGame_06;

class MainGame_07
{
private:
	int m_nNumber;

public:
	// 일반 함수
	void outPutValue();
	void outPutValue(int num);

	// 템플릿 함수 선언
	template <typename T> void outPutFunc(T num);
	template <typename T1, typename T2> void outPutFunc(T1 numL, T2 numR);

	template <typename T3> T3 maxValue(T3 numL, T3 numR);
	template <typename T4> T4 addValue(T4 numL, T4 numR);
	template <typename T5> T5 riskValue(T5 numL, T5 numR);

	template <typename T>
	void Swap(T& a_rtLhs, T& a_rtRhs)
	{
		T tTemp = a_rtLhs;
		a_rtLhs = a_rtRhs;
		a_rtRhs = tTemp;
	}

	/*
	- C++ 언어의 템플릿 함수 또는 클래스는 기본적으로 모든 데이터 타입에 동작하도록
	  로직을 작성하는게 원칙이지만 특정 데이터 타입에 동작하도록 로직을 구성하는게
	  불가능하다면 해당 타입에 동작하도록 로직을 별도로 구성하는것을 지원한다.
	
	- 이를 템플릿 특수화라고 한다.

	*/
	// 템플릿 특수화 예시
	// 1. 자료형을 명시한다.
	template <>
	void Swap(std::string& a_rtLhs,std::string& a_rtRhs)
	{
		std::string oTemp = a_rtLhs;
		a_rtLhs = a_rtRhs;
		a_rtRhs = oTemp;

		cout << "템플릿 특수화 함수 호출!" << endl;
	}


	MainGame_07();
	~MainGame_07();

};

// 템플릿 함수를 일반적으로 구현하는 방법
//template <typename T>
//inline void MainGame_07::outPutFunc(T num)
//{
//
//}
//
//template <typename T1, typename T2>
//inline void MainGame_07::outPutFunc(T1 numL, T2 numR)
//{
//
//}

