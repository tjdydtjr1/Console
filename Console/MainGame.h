#pragma once
#include <iostream>

using std::cout;
using std::cin;
using std::endl;

#pragma region 클래스
/*
=> 클래스

- 속성에 해당하는 필드(변수)와 행위에 해당하는 메서드(함수)의 집합을 클래스라고 한다.
ㄴ 클래스를 이용하면 데이터 뿐만 아니라 함수를 특정 집합에 포함하는게 가능하다.

-> C/C++ 언어의 클래스 선언 방법

EX)
class CUnit
{
private:
	int m_ID;
	std::string m_Name;

	void setInfo(int m_ID, std::string m_Name);

	void printInfo(void);
};

- C/C++ 언어의 클래스는 접근 제어 지시자를 이용해서 변수 또는 함수에
접근할 수 있는 영역을 제한하는 것이 가능하다.

=> 클래스의 접근 제어 지시자
표준 3가지
1. private
ㄴ 클래스에 포함된 함수에서만 접근이 가능하도록 허용
ㄴ 클래스에서 기본적으로 접근 제어 지시자를 적지 않으면 private 이다.
ㄴ 캡슐화

- 이 속성을 가지는 멤버는 외부에서 엑세스 할수 없으며 구조체의 멤버 함수만
엑세스 할 수 있다.

- 외부에서는 private 멤버를 읽을 수 없음은 물론이고 존재 자체도 알려지지 않는다.

2. public
ㄴ 어디서든 접근이 가능하도록 허용

- 이 속성을 가지는 멤버는 외부로 공개되어 누구나 읽고 쓸 수 있으며 함수의
경우에는 호출까지 가능하다.

- 구조체가 자신의 속성이나 동작을 외부로 공개하는 수단이 되며 public 멤버를
소위 "Interface"라고 부른다.

3. protected
ㄴ 상속 관계에 있을 때 자식 클래스에서 부모 클래스에 접근하도록 허용

- private와 마찬가지로 외부에서는 엑세스 할 수 없으나 상속된 파생 클래스는
이 멤버를 엑세스 할 수 있다는 차이점이 존재

- private 멤버는 파생 클래스에서 조차 참조할 수 없으며 오로지 자신만이
이 멤버를 참조할 수 있다는 점에서 차이점이 발생한다.


// JAVV,Python에 있던 접근 제어 지시자를 C++17 부터 가져옴
(4. internal) (방어용으로 간단하게만 알고 있자)
ㄴ private와 public의 중간 형태로 어셈블리 내에 상속 클래스에서만
접근이 가능
ㄴ 동일 어셈블리 안이라면 public / 밖이라면 private
ㄴ => 유니티의 씬매니저 

******************************************************************
- 클래스는 객체의 안정성을 위해 외부에서 함부로 값을 건드리지 못하도록
멤버를 숨기는 경향이 있지만 구조체는 가급적으로 공개하려는 경향이 있다.

- 구조체의 디폴트 엑세스 지정이 public일 수 밖에 없는 이유는 C언어와의
호환성 때문

- 면접 사골 질문
ㄴ 구조체(기본 public)와 클래스(기본 private)의 차이점에 대해서 얘기해 보시오. (C++와 C#은 차이점이 다름)
- 구조체의 멤버는 public 속성을 가지며 외부에 공개 되지만 클래스의 멤버는 private 속성을 가지기 때문에
외부에 비공개 처리 된다.


-> 구조체도 접근 제어 지시자 사용이 가능하다
ㄴ 클래스로 만들기엔 작고 데이터들의 집합을 구조체로 만들 때 사용한다.

******************************************************************

OOP 4대 특징 , 5가지 설계 원칙


*/
#pragma endregion

struct tagPlayer
{
	int hp;
	int mp;
};

class MainGame
{
	// 익숙해지기 전까지는 변수 선언 -> private 안에서
	// 클래스 안에서 변수를 선언할때는 'm' / '_'를 사용하는 경우가 많다.
	// ㄴ 클래스 멤버 변수임을 명시하겠다.
private:
	//   선언과 초기화는 구분한다.
	//ㄴ 상속 관계에서 호출 순서에 따른 초기화 된 값이 안들어가는 경우 발생
	int _Number;
	int _x;
	int _y;
	// const 는 초기화를 하는 경우가 많다.

	/*
	C++11 부터는 클래스의 멤버 변수의 선언과 동시에 초기화를 시킬 수 있는 기능이 추가 됐다.
	추가가 되면서 멤버 이니셜라이저를 이용하지 않더라도 심볼릭 상수등을
	초기화 하는것이 가능하다.
	ㄴ 단, 상속관계와 클래스가 많아질수록 잠재적인 오류를 발생시킬 여지를 가지고 있다.
	*/
	int m_nId = 0;
	std::string m_oName = "";
	const int m_nConstValue = 0;

	// 함수 선언은 public 지정자 범위에서 선언한다.
	// ㄴ 함수를 선언했으면 구현부/ 몸통 등등 -> cpp에 정의
public:
	// 일반적으로 cpp에서 함수를 구현해야 한다.
	void outPut();
	// 위치 좌표
	void showPosition(void);
	// 위치 증가
	void movePosition(void);
	// 위치 좌표 세팅
	void setPosition(int x, int y);

	// 생성자 : 주로 멤버 변수의 값을 원하는 값으로 대입하는 작업을 한다.
	// 그 외에도 객체가 동작하는데 필요한 모든 초기화 처리를 담당하기도 한다.
	MainGame();
	// 소멸자 : 객체가 바꿔놓은 환경을 원래대로 돌려 놓거나 할당한 자원을
	// 회수하는 역할을 한다. (동적 할당등의 메모리 해제)
	~MainGame();
};

