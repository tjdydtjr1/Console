#pragma once
#include <iostream>


using std::cout;
using std::cin;
using std::endl;
using std::string;

#pragma region 가상 함수
/*
=> 가상 함수란?

- 부모 클래스의 특정 함수가 자식 클래스에 재정의 되어 있을 경우 부모 클래스의
  참조 또는 포인터를 가지고 자식 클래스의 특정 함수를 실행 시키는 메커니즘을
  의미 한다.

- 가상 함수를 이용하면 객체의 계층 구조에 따라 자식 클래스의 특정 함수를
  호출하는 것이 가능하다.

-> 가상 함수 특징
- C++ 클래스의 특징중 하나인 다형성을 지원하기 위해 "virtual" 키워드를
  사용한다.
- 부모 클래스내에서 virtual로 선언된 함수는 자식 클래스에서 재정의 될 수 있다.
  (오버라이딩)
- 재정의 되지 않았다면 호출 시 부모 클래스의 함수가 호출이 되고 재정의 되었다면
  함수 호출시 자식 클래스의 함수가 호출된다. (가상 함수 테이블)


=> 다형성?
- 여러가지를 표현할 수 있다는 뜻
- 자식 객체의 인스턴스를 부모 객체의 타입으로 간접 지정이 가능하다는걸 뜻한다.

=> 인스턴스?
- 어느 클래스에 속하는 각 객체를 인스턴스라고 한다.

EX)
- 집이라는 클래스를 만들고 내 방이라는 객체를 생성하면 그 클래스의 인스턴스가
  생성된다.


함수 오버로딩 + 함수 오버라이딩

*/


#pragma endregion

// 부모
class weapon
{
public:
	virtual void attack()
	{
		cout << "무기로 공격" << endl; 
	}
};

class gun : public weapon
{
public:
	void attack()
	{
		cout << "총으로 공격" << endl;
	}
};
class bow : public weapon
{
public:
	void attack()
	{
		cout << "활로 공격" << endl;
	}
};

// 순수 가상함수
class AClass
{
public:
	// 순수 가상함수 : 함수의 몸체가 정의되지 않는 함수				
	// = 0; 몸통을 명시적으로 정의하지 않겠다.
	// - 순수 가상함수로만 만들어진 클래스를 인터페이스라고 부른다.
	// - 인터페이스는 인스턴스를 생성할 수 없다.
	virtual void ClassFunction() = 0;
	// 상속을 통해 오버라이딩으로 자식 클래스에서 재정의해서 사용한다.

	// 인터페이스 클래스는 생성자 소멸자가 호출될 필요가 없다.
	AClass() {}
	virtual ~AClass() {}

	/*
	=> 상속 관계에서의 생성과 소멸
	- 상속을 받은 클래스의 생성과 소멸 과정에는 동일한 규칙이 적용된다.
	ㄴ 부모 클래스의 생성자에서 자식 클래스의 생성자 순서로 호출이 되고
	  소멸자는 자식 클래스의 소멸자가 먼저 호출이 되면서 부모 클래스의
	  소멸자가 호출이 되는 구조를 가지고 있다.

	- 부모 클래스의 포인터로 자식 클래스를 호출할 때 가상 함수로 정의되어
	  있지 않은 자식 클래스의 오버라이딩된 함수를 호출하면 부모 클래스의
	  멤버 함수가 호출이 된다. 이를 "다형성" 이라고 했었다.

	- 소멸자도 자식 클래스에서 오버라이딩된 함수라고 볼 수 있기 때문에
	  만약 부모 포인터로 객체를 삭제하면 부모 클래스의 소멸자가 호출이 된다.
	- 따라서 소멸자를 가상 함수로 선언하지 않으면 다형성 메커니즘이 동작하지
	  않기 때문에 자식 클래스의 소멸자는 결코 호출이 되지 않는 불상사가
	  발생 한다.
	  ㄴ 이는 곧 메모리 누수 당첨

	- 가상 함수 키워드를 사용했다면 이것은 자식 클래스에서 재정의될 수 있음을
	  명시한것이기 때문에 포인터의 종류에 상관없이 자식 클래스의 함수가
	  호출되는 결과를 볼 수 있다. (재정의 되었다면.)

	* 자식 클래스 소멸자 호출 -> 부모 클래스의 소멸자를 호출하기 위해
	  ㄴ 소멸자에서 해제가 필요한 경우 (상속 관계) 소멸자에 가상화를
		 고민 해봐야 한다.

	*/
};




class MainGame_04
{
private:
	// 아래와 같이 하면 부모만 참조 자식 x -> C++만 가능
	// 재 생산성이 늘어남
	weapon* _gun;
	weapon* _bow;
	weapon* _myWeapon;
	
public:
	MainGame_04();
	~MainGame_04();

};

/*
과제1. 숫자 야구 클래스로 나누기

- 두가지 버전
ㄴ 1. 가상화가 있는 버전 1개
ㄴ 2. 클래스가 최소 8개 있는 버전 1개

- 메인 함수에서 클래스를 선택해 원하는 버전을 플레이 할 수 있게 만든다.

과제2. 포트폴리오 선행 작업

- 도트를 추천

복습은 꼭 한다.

열심히 조사
- 노트에 적어온다.
- STL + 자료 구조 + 스택 + 큐 + 트리 + 벡터
  + 리스트 + 맵 + 반복자 + 컨테이너

*/